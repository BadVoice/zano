[1mdiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt[m
[1mindex 2d715644..27739818 100644[m
[1m--- a/src/CMakeLists.txt[m
[1m+++ b/src/CMakeLists.txt[m
[36m@@ -184,7 +184,7 @@[m [mENABLE_SHARED_PCH_EXECUTABLE(connectivity_tool)[m
 [m
 add_executable(simplewallet ${SIMPLEWALLET})[m
 add_dependencies(simplewallet version) [m
[31m-target_link_libraries(simplewallet wallet rpc currency_core crypto common zlibstatic ethash ${CMAKE_THREAD_LIBS_INIT} ${Boost_LIBRARIES} OpenSSL::SSL OpenSSL::Crypto stdc++fs)[m
[32m+[m[32mtarget_link_libraries(simplewallet wallet rpc currency_core crypto common zlibstatic ethash ${CMAKE_THREAD_LIBS_INIT} ${Boost_LIBRARIES} OpenSSL::SSL OpenSSL::Crypto)[m
 [m
 ENABLE_SHARED_PCH(simplewallet SIMPLEWALLET)[m
 ENABLE_SHARED_PCH_EXECUTABLE(simplewallet)[m
[1mdiff --git a/src/crypto/crypto.h b/src/crypto/crypto.h[m
[1mindex 08cf26d5..160929f8 100644[m
[1m--- a/src/crypto/crypto.h[m
[1m+++ b/src/crypto/crypto.h[m
[36m@@ -302,11 +302,10 @@[m [mnamespace crypto {[m
 } // namespace crypto[m
 [m
 POD_MAKE_HASHABLE(crypto, public_key)[m
[31m-POD_MAKE_LESS_OPERATOR(crypto, public_key)[m
 POD_MAKE_COMPARABLE(crypto, secret_key)[m
 POD_MAKE_HASHABLE(crypto, key_image)[m
 POD_MAKE_COMPARABLE(crypto, signature)[m
 POD_MAKE_COMPARABLE(crypto, key_derivation)[m
 POD_MAKE_LESS_OPERATOR(crypto, hash)[m
 POD_MAKE_LESS_OPERATOR(crypto, key_image)[m
[31m-POP_GCC_WARNINGS[m
[32m+[m[32mPOP_GCC_WARNINGS[m
\ No newline at end of file[m
[1mdiff --git a/src/gui/qt-daemon/layout b/src/gui/qt-daemon/layout[m
[1mindex 1b080e0b..317979cd 160000[m
[1m--- a/src/gui/qt-daemon/layout[m
[1m+++ b/src/gui/qt-daemon/layout[m
[36m@@ -1 +1 @@[m
[31m-Subproject commit 1b080e0be4cdace91a0ba7c171e6ed349cf1aa25[m
[32m+[m[32mSubproject commit 317979cdf88fc2ca785a3f1a0e0578b7a0f42ff5[m
[1mdiff --git a/src/simplewallet/simplewallet.cpp b/src/simplewallet/simplewallet.cpp[m
[1mindex ddb34a81..4178ddee 100644[m
[1m--- a/src/simplewallet/simplewallet.cpp[m
[1m+++ b/src/simplewallet/simplewallet.cpp[m
[36m@@ -142,7 +142,6 @@[m [mnamespace[m
   const command_line::arg_descriptor<bool>          arg_no_password_confirmations("no-password-confirmation", "Enable/Disable password confirmation for transactions", false);[m
   const command_line::arg_descriptor<bool>          arg_seed_doctor("seed-doctor", "Experimental: if your seed is not working for recovery this is likely because you've made a mistake whene you were doing back up(typo, wrong words order, missing word). This experimental code will attempt to recover seed phrase from with few approaches.");[m
   const command_line::arg_descriptor<bool>          arg_no_whitelist("no-white-list", "Do not load white list from interned.");[m
[31m-  const command_line::arg_descriptor<std::string>   arg_restore_ki_in_wo_wallet("restore-ki-in-wo-wallet", "Watch-only missing key images restoration. Please, DON'T use it unless you 100% sure of what are you doing.", "");[m
 [m
   const command_line::arg_descriptor< std::vector<std::string> > arg_command  ("command", "");[m
 [m
[36m@@ -520,8 +519,6 @@[m [mbool simple_wallet::init(const boost::program_options::variables_map& vm)[m
     bool r = open_wallet(m_wallet_file, pwd_container.password());[m
     CHECK_AND_ASSERT_MES(r, false, "wallet could not be opened");[m
     was_open = true;[m
[31m-    if (!process_ki_restoration())[m
[31m-      return false;[m
   }[m
   process_wallet_command_line_params(vm, *m_wallet, false);[m
 [m
[36m@@ -562,7 +559,6 @@[m [mvoid simple_wallet::handle_command_line(const boost::program_options::variables_[m
   m_voting_config_file = command_line::get_arg(vm, arg_voting_config_file);[m
   m_no_password_confirmations = command_line::get_arg(vm, arg_no_password_confirmations);  [m
   m_no_whitelist = command_line::get_arg(vm, arg_no_whitelist);[m
[31m-  m_restore_ki_in_wo_wallet = command_line::get_arg(vm, arg_restore_ki_in_wo_wallet);[m
 } [m
 //----------------------------------------------------------------------------------------------------[m
 [m
[36m@@ -724,7 +720,7 @@[m [mbool simple_wallet::open_wallet(const string &wallet_file, const std::string& pa[m
     try[m
     {[m
       m_wallet->load(epee::string_encoding::utf8_to_wstring(m_wallet_file), password);[m
[31m-      print_wallet_opened_msg();[m
[32m+[m[32m      message_writer(epee::log_space::console_color_white, true) << "Opened" << (m_wallet->is_auditable() ? " auditable" : "") << (m_wallet->is_watch_only() ? " watch-only" : "") << " wallet: " << m_wallet->get_account().get_public_address_str();[m
       preconfig_wallet_obj();[m
       display_vote_info(*m_wallet);[m
       [m
[36m@@ -787,28 +783,6 @@[m [mbool simple_wallet::save(const std::vector<std::string> &args)[m
   return true;[m
 }[m
 //----------------------------------------------------------------------------------------------------[m
[31m-bool simple_wallet::process_ki_restoration()[m
[31m-{[m
[31m-  bool r = false;[m
[31m-  if (!m_restore_ki_in_wo_wallet.empty())[m
[31m-  {[m
[31m-    std::wstring wo_filename = epee::string_encoding::utf8_to_wstring(m_restore_ki_in_wo_wallet);[m
[31m-    CHECK_AND_ASSERT_THROW_MES(std::filesystem::exists(wo_filename), "cannot open " << m_restore_ki_in_wo_wallet);[m
[31m-[m
[31m-    tools::password_container wo_password;[m
[31m-    if (!wo_password.read_password("Enter password for wallet " + m_restore_ki_in_wo_wallet + " :"))[m
[31m-      return false;[m
[31m-[m
[31m-    m_wallet->restore_key_images_in_wo_wallet(wo_filename, wo_password.password());[m
[31m-[m
[31m-    success_msg_writer() << "Missing key images have been successfully repared in " << m_restore_ki_in_wo_wallet << ENDL;[m
[31m-    [m
[31m-    return false; // means the wallet processing should stop now[m
[31m-  }[m
[31m-[m
[31m-  return true; // means the wallet can load and work further normally[m
[31m-}[m
[31m-//----------------------------------------------------------------------------------------------------[m
 #ifdef CPU_MINING_ENABLED[m
 bool simple_wallet::start_mining(const std::vector<std::string>& args)[m
 {[m
[36m@@ -3271,8 +3245,6 @@[m [mint main(int argc, char* argv[])[m
   command_line::add_arg(desc_params, arg_seed_doctor);[m
   command_line::add_arg(desc_params, arg_derive_custom_seed);[m
   command_line::add_arg(desc_params, arg_no_whitelist);[m
[31m-  command_line::add_arg(desc_params, arg_restore_ki_in_wo_wallet);[m
[31m-[m
 [m
   tools::wallet_rpc_server::init_options(desc_params);[m
 [m
[1mdiff --git a/src/simplewallet/simplewallet.h b/src/simplewallet/simplewallet.h[m
[1mindex 789ada28..6577b6a7 100644[m
[1m--- a/src/simplewallet/simplewallet.h[m
[1m+++ b/src/simplewallet/simplewallet.h[m
[36m@@ -181,7 +181,6 @@[m [mnamespace currency[m
 [m
   private:[m
     void preconfig_wallet_obj();[m
[31m-    bool process_ki_restoration();[m
 [m
     std::string m_wallet_file;[m
     std::string m_generate_new;[m
[36m@@ -200,7 +199,6 @@[m [mnamespace currency[m
     std::string m_voting_config_file;[m
     bool m_no_password_confirmations = false;[m
     bool m_no_whitelist = false;[m
[31m-    std::string m_restore_ki_in_wo_wallet;[m
     [m
     crypto::hash m_password_hash;[m
     uint64_t m_password_salt;[m
[1mdiff --git a/src/version.h.in b/src/version.h.in[m
[1mindex d1735074..51f7e11f 100644[m
[1m--- a/src/version.h.in[m
[1m+++ b/src/version.h.in[m
[36m@@ -8,6 +8,6 @@[m
 #define PROJECT_REVISION "8"[m
 #define PROJECT_VERSION PROJECT_MAJOR_VERSION "." PROJECT_MINOR_VERSION "." PROJECT_REVISION[m
 [m
[31m-#define PROJECT_VERSION_BUILD_NO 414[m
[32m+[m[32m#define PROJECT_VERSION_BUILD_NO 413[m
 #define PROJECT_VERSION_BUILD_NO_STR STRINGIFY_EXPAND(PROJECT_VERSION_BUILD_NO)[m
 #define PROJECT_VERSION_LONG PROJECT_VERSION "." PROJECT_VERSION_BUILD_NO_STR "[" BUILD_COMMIT_ID "]"[m
[1mdiff --git a/src/wallet/wallet2.cpp b/src/wallet/wallet2.cpp[m
[1mindex 59d24d61..59107e5f 100644[m
[1m--- a/src/wallet/wallet2.cpp[m
[1m+++ b/src/wallet/wallet2.cpp[m
[36m@@ -92,11 +92,6 @@[m [mnamespace tools[m
     m_core_runtime_config = currency::get_default_core_runtime_config();[m
   }[m
   //---------------------------------------------------------------[m
[31m-  wallet2::~wallet2()[m
[31m-  {[m
[31m-    // do nothing[m
[31m-  }[m
[31m-  //---------------------------------------------------------------[m
   uint64_t wallet2::get_max_unlock_time_from_receive_indices(const currency::transaction& tx, const wallet_public::employed_tx_entries& td)[m
   {[m
     uint64_t max_unlock_time = 0;[m
[36m@@ -5236,11 +5231,7 @@[m [mbool wallet2::reset_history()[m
   std::wstring file_path = m_wallet_file;[m
   account_base acc_tmp = m_account;[m
   auto tx_keys = m_tx_keys;[m
[31m-  auto pending_key_images = m_pending_key_images;[m
[31m-  crypto::hash genesis_id = m_chain.get_genesis();[m
   clear();[m
[31m-  m_chain.set_genesis(genesis_id);[m
[31m-  m_pending_key_images = pending_key_images;[m
   m_tx_keys = tx_keys;[m
   m_account = acc_tmp;[m
   m_password = pass;[m
[36m@@ -7867,122 +7858,6 @@[m [mbool wallet2::is_need_to_split_outputs()[m
   return !is_in_hardfork_zone(ZANO_HARDFORK_04_ZARCANUM);[m
 }[m
 //----------------------------------------------------------------------------------------------------[m
[31m-void wallet2::restore_key_images_in_wo_wallet(const std::wstring& filename, const std::string& password) const[m
[31m-{[m
[31m-  WLT_THROW_IF_FALSE_WALLET_CMN_ERR_EX(!m_watch_only, "restore_key_images_in_wo_wallet can only be used in non watch-only wallet");[m
[31m-  bool r = false;[m
[31m-[m
[31m-  // load the given watch-only wallet[m
[31m-  wallet2 wo;[m
[31m-  wo.load(filename, password);[m
[31m-  WLT_THROW_IF_FALSE_WALLET_CMN_ERR_EX(wo.is_watch_only(), epee::string_encoding::wstring_to_utf8(filename) << " is not a watch-only wallet");[m
[31m-  if (m_account.get_keys().view_secret_key != wo.get_account().get_keys().view_secret_key ||[m
[31m-    m_account.get_public_address() != wo.get_account().get_public_address())[m
[31m-  {[m
[31m-    WLT_THROW_IF_FALSE_WALLET_CMN_ERR_EX(false, epee::string_encoding::wstring_to_utf8(filename) << " has keys that differ from this wallet's keys; wrong wallet?");[m
[31m-  }[m
[31m-[m
[31m-  //[m
[31m-  // 1. Find missing key images and calculate them using secret spend key. Populate missing_ki_items container.[m
[31m-  //[m
[31m-  struct missing_ki_item[m
[31m-  {[m
[31m-    crypto::public_key  tx_pub_key;[m
[31m-    crypto::public_key  out_pub_key;[m
[31m-    uint64_t            output_index;[m
[31m-    uint64_t            transfer_index;[m
[31m-    crypto::key_image   ki;[m
[31m-  };[m
[31m-[m
[31m-  std::set<size_t> transfer_indices_to_include;[m
[31m-  for(auto el : wo.m_pending_key_images)[m
[31m-  {[m
[31m-    const crypto::key_image& ki = el.second;[m
[31m-    auto it = wo.m_key_images.find(ki);[m
[31m-    WLT_THROW_IF_FALSE_WALLET_INT_ERR_EX(it != wo.m_key_images.end(), "restore_key_images_in_wo_wallet: m_key_images inconsistency, ki: " << ki);[m
[31m-    size_t transfer_index = it->second;[m
[31m-    transfer_indices_to_include.insert(transfer_index);[m
[31m-    WLT_LOG_L1("restore_key_images_in_wo_wallet: transfer " << transfer_index << " is in m_pending_key_images, included");[m
[31m-  }[m
[31m-[m
[31m-  for(auto el : wo.m_transfers)[m
[31m-  {[m
[31m-    size_t transfer_index = el.first;[m
[31m-    if (el.second.m_key_image == null_ki)[m
[31m-    {[m
[31m-      transfer_indices_to_include.insert(transfer_index);[m
[31m-      WLT_LOG_L1("restore_key_images_in_wo_wallet: ki is null for ti " << transfer_index << ", included");[m
[31m-    }[m
[31m-  }[m
[31m-[m
[31m-  // now in transfer_indices_to_include we have ordered and unique list of transfer indices[m
[31m-  std::vector<missing_ki_item> missing_ki_items;[m
[31m-  std::set<crypto::public_key> pk_uniqueness_set;[m
[31m-  for(size_t transfer_index : transfer_indices_to_include)[m
[31m-  {[m
[31m-    const auto& td = wo.m_transfers.at(transfer_index);[m
[31m-    auto& item = missing_ki_items.emplace_back();[m
[31m-    item.output_index = td.m_internal_output_index;[m
[31m-    crypto::public_key out_pub_key{};[m
[31m-    r = get_out_pub_key_from_tx_out_v(td.output(), out_pub_key);[m
[31m-    WLT_THROW_IF_FALSE_WALLET_INT_ERR_EX(r, "restore_key_images_in_wo_wallet failed for ti: " << transfer_index);[m
[31m-    WLT_THROW_IF_FALSE_WALLET_INT_ERR_EX(pk_uniqueness_set.insert(out_pub_key).second, "restore_key_images_in_wo_wallet: out pub key in not unique: " << out_pub_key << ", ti: " << transfer_index);[m
[31m-    item.out_pub_key = out_pub_key;[m
[31m-    item.transfer_index = transfer_index;[m
[31m-    item.tx_pub_key = get_tx_pub_key_from_extra(td.m_ptx_wallet_info->m_tx);[m
[31m-    WLT_LOG_L0("restore_key_images_in_wo_wallet: including: " << item.out_pub_key << ", " << transfer_index);[m
[31m-[m
[31m-    // calculate key image[m
[31m-    keypair ephemeral{};[m
[31m-    generate_key_image_helper(m_account.get_keys(), item.tx_pub_key, item.output_index, ephemeral, item.ki);[m
[31m-    WLT_THROW_IF_FALSE_WALLET_CMN_ERR_EX(ephemeral.pub == item.out_pub_key, "restore_key_images_in_wo_wallet: out pub key missmatch, ti: " << transfer_index);[m
[31m-  };[m
[31m-[m
[31m-  //[m
[31m-  // 2. Actually restore key images in the 'wo' object.[m
[31m-  //[m
[31m-  r = wo.m_pending_key_images_file_container.clear();[m
[31m-  WLT_THROW_IF_FALSE_WALLET_CMN_ERR_EX(r, "restore_key_images_in_wo_wallet: pending ki container clearing failed");[m
[31m-  wo.m_pending_key_images.clear();[m
[31m-[m
[31m-  for(size_t i = 0; i < missing_ki_items.size(); ++i)[m
[31m-  {[m
[31m-    const auto& item = missing_ki_items[i];[m
[31m-    auto& td = wo.m_transfers[item.transfer_index]; // item.transfer_index validity was checked above[m
[31m-[m
[31m-    td.m_key_image = item.ki; // TODO: it's unclear whether we need to update m_transfers[].m_key_image since later I decided to clear history to trigger resync later. Probably, no. -- sowle[m
[31m-    r = wo.m_pending_key_images.insert(std::make_pair(item.out_pub_key, item.ki)).second;[m
[31m-    WLT_THROW_IF_FALSE_WALLET_INT_ERR_EX(r, "restore_key_images_in_wo_wallet: insert failed, out_pub_key: " << item.out_pub_key << ", i: " << i);[m
[31m-    wo.m_pending_key_images_file_container.push_back(out_key_to_ki{item.out_pub_key, item.ki});[m
[31m-    LOG_PRINT_L0("restore_key_images_in_wo_wallet: added #" << i << " ti: " << item.transfer_index << ", pk: " << item.out_pub_key << ", ki: " << item.ki);[m
[31m-  }[m
[31m-[m
[31m-  wo.reset_history();[m
[31m-  wo.store();[m
[31m-}[m
[31m-//----------------------------------------------------------------------------------------------------[m
[31m-void wallet2::clear_utxo_cold_sig_reservation(std::vector<uint64_t>& affected_transfer_ids)[m
[31m-{[m
[31m-  WLT_THROW_IF_FALSE_WALLET_CMN_ERR_EX(m_watch_only, "clear_utxo_cold_sig_reservation can only be used in watch-only wallet");[m
[31m-  affected_transfer_ids.clear();[m
[31m-[m
[31m-  for(auto& [tid, td] : m_transfers)[m
[31m-  {[m
[31m-    if (!td.is_spent() && (td.m_flags & WALLET_TRANSFER_DETAIL_FLAG_COLD_SIG_RESERVATION) != 0)[m
[31m-    {[m
[31m-      affected_transfer_ids.push_back(tid);[m
[31m-      crypto::public_key pk{};[m
[31m-      get_out_pub_key_from_tx_out_v(td.output(), pk);[m
[31m-      WLT_LOG_L0("clear_utxo_cold_sig_reservation: tid: " << tid << ", pk: " << pk << ", amount: " << td.amount() <<[m
[31m-        (!td.is_native_coin() ? std::string(", aid: ") + crypto::pod_to_hex(td.get_asset_id()) : std::string()) <<[m
[31m-        (td.m_key_image != null_ki ? std::string(", ki: ") + crypto::pod_to_hex(td.m_key_image) : std::string()));[m
[31m-    }[m
[31m-  }[m
[31m-[m
[31m-  clear_transfers_from_flag(affected_transfer_ids, WALLET_TRANSFER_DETAIL_FLAG_COLD_SIG_RESERVATION, "clear_utxo_cold_sig_reservation");[m
[31m-  m_found_free_amounts.clear();[m
[31m-}[m
[31m-//----------------------------------------------------------------------------------------------------[m
 void wallet2::prepare_tx_destinations(const assets_selection_context& needed_money_map,[m
   detail::split_strategy_id_t destination_split_strategy_id,[m
   const tx_dust_policy& dust_policy,[m
[1mdiff --git a/src/wallet/wallet2.h b/src/wallet/wallet2.h[m
[1mindex 8e20d0c0..4d3fa218 100644[m
[1m--- a/src/wallet/wallet2.h[m
[1m+++ b/src/wallet/wallet2.h[m
[36m@@ -262,7 +262,7 @@[m [mnamespace tools[m
     wallet2(const wallet2&) = delete;[m
   public:[m
     wallet2();[m
[31m-    virtual ~wallet2();[m
[32m+[m[32m    virtual ~wallet2() {}[m
 [m
     static std::string transfer_flags_to_str(uint32_t flags);[m
 [m
[36m@@ -617,9 +617,6 @@[m [mnamespace tools[m
     void submit_transfer_files(const std::string& signed_tx_file, currency::transaction& tx);[m
     void submit_externally_signed_asset_tx(const currency::finalized_tx& ft, const crypto::generic_schnorr_sig_s& gss_sig, bool unlock_transfers_on_fail, currency::transaction& result_tx, bool& transfers_unlocked);[m
     void submit_externally_signed_asset_tx(const currency::finalized_tx& ft, const crypto::eth_signature& eth_sig, bool unlock_transfers_on_fail, currency::transaction& result_tx, bool& transfers_unlocked);[m
[31m-    [m
[31m-    void restore_key_images_in_wo_wallet(const std::wstring& filename, const std::string& password) const;[m
[31m-    void clear_utxo_cold_sig_reservation(std::vector<uint64_t>& affected_transfer_ids);[m
 [m
     void sweep_below(size_t fake_outs_count, const currency::account_public_address& destination_addr, uint64_t threshold_amount, const currency::payment_id_t& payment_id,[m
       uint64_t fee, size_t& outs_total, uint64_t& amount_total, size_t& outs_swept, uint64_t& amount_swept, currency::transaction* p_result_tx = nullptr, std::string* p_filename_or_unsigned_tx_blob_str = nullptr);[m
[1mdiff --git a/src/wallet/wallet_public_structs_defs.h b/src/wallet/wallet_public_structs_defs.h[m
[1mindex f3908c24..3ac0f839 100644[m
[1m--- a/src/wallet/wallet_public_structs_defs.h[m
[1m+++ b/src/wallet/wallet_public_structs_defs.h[m
[36m@@ -2159,35 +2159,5 @@[m [mnamespace wallet_public[m
     };[m
   };[m
 [m
[31m-  struct COMMAND_CLEAR_UTXO_COLD_SIG_RESERVATION[m
[31m-  {[m
[31m-    DOC_COMMAND("Clears cold sig reservation flag for all unspent transaction outputs, that have one. Please, use with CAUTION!");[m
[31m-[m
[31m-    struct request[m
[31m-    {[m
[31m-      BEGIN_KV_SERIALIZE_MAP()[m
[31m-      END_KV_SERIALIZE_MAP()[m
[31m-    };[m
[31m-[m
[31m-    struct response_item[m
[31m-    {[m
[31m-      crypto::public_key pk;[m
[31m-      BEGIN_KV_SERIALIZE_MAP()[m
[31m-        KV_SERIALIZE_POD_AS_HEX_STRING(pk)       DOC_DSCR("Output's one-time public key") DOC_EXMP("f74bb56a5b4fa562e679ccaadd697463498a66de4f1760b2cd40f11c3a00a7a8") DOC_END[m
[31m-      END_KV_SERIALIZE_MAP()[m
[31m-    };[m
[31m-[m
[31m-    struct response[m
[31m-    {[m
[31m-      std::string                     status;[m
[31m-      std::vector<response_item>      affected_outputs;[m
[31m-[m
[31m-      BEGIN_KV_SERIALIZE_MAP()[m
[31m-        KV_SERIALIZE(status)                     DOC_DSCR("Status of the call") DOC_EXMP("OK") DOC_END[m
[31m-        KV_SERIALIZE(affected_outputs)           DOC_DSCR("List of affected outputs (for reference).") DOC_EXMP_AUTO(1) DOC_END[m
[31m-      END_KV_SERIALIZE_MAP()[m
[31m-    };[m
[31m-  };[m
[31m-[m
 } // namespace wallet_rpc[m
 } // namespace tools[m
[1mdiff --git a/src/wallet/wallet_rpc_server.cpp b/src/wallet/wallet_rpc_server.cpp[m
[1mindex 13922a20..15a4d276 100644[m
[1m--- a/src/wallet/wallet_rpc_server.cpp[m
[1m+++ b/src/wallet/wallet_rpc_server.cpp[m
[36m@@ -1620,31 +1620,6 @@[m [mnamespace tools[m
     WALLET_RPC_CATCH_TRY_ENTRY();[m
   }[m
   //------------------------------------------------------------------------------------------------------------------------------[m
[31m-  bool wallet_rpc_server::on_clear_utxo_cold_sig_reservation(const wal